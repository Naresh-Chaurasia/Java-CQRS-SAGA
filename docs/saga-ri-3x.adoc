= CQRS Event-Driven Product Storage System
:toc: right
:toclevels:
:sectnums:
:sectnumlevel

== Architecture Overview

This system implements *CQRS (Command Query Responsibility Segregation)* with *Event Sourcing* using the Axon Framework.

The core idea is simple:

* Write operations (commands) and read operations (queries) are separated
* Every change in the system is recorded as an *event*
* Read data is built by listening to these events

---

== Command Flow (Write Side)

When a product is created, the following flow is executed:

```
REST API → CreateProductCommand → ProductAggregate → ProductCreatedEvent → Event Bus
```

---

*Step-by-Step Explanation (Simple Language)*

*1. REST API (User request entry point)*

* Create a product with this title, price, and quantity
* The REST controller:
** Only converts the request into a command

*In simple words:*: The user is telling the system *what they want to do*.

---

*2. CreateProductCommand (Instruction)*

* A command represents an *action request*.
* `CreateProductCommand` contains:

* productId, title, price, quantity

*In simple words:* This is a *written instruction* saying: “Create this product.”

---

*3. ProductAggregate (Decision maker)*

* The command is handled by the **ProductAggregate**.

* The aggregate:
** Acts as the *authority*
** Enforces business rules

* It checks:
** Is the data valid?
** Can this product be created?

* *If everything is valid*:
** It does *not* write to the database
** #It creates an event#

*In simple words:*
The aggregate decides:
“Yes, this operation is allowed.”

---

*4. ProductCreatedEvent (Something that already happened)*

* An event represents a *fact*.

* `ProductCreatedEvent` means:
** “The product has been created”

* Events are:
** Immutable (cannot be changed)
** Stored for history and auditing

*In simple words:* This is like a **receipt** confirming: “The product was created.”

---

*5. Event Bus (Announcement system)*

* The event is published to the **Event Bus**.

* The Event Bus:
** Broadcasts the event
** Delivers it to all interested listeners

* Examples of listeners:
** ProductEventsHandler (updates H2 database)
** Logging services
** Analytics services
** Notification services

*In simple words:*
The system announces:
“A product has been created!”

---

*One-Line Summary of the Flow*

* REST API → User request
* Command → What to do
* Aggregate → Is it allowed?
* Event → What happened
* Event Bus → Tell everyone

---

##############################################

*4.3. Event Processing (Event Sourcing)*

After the event is published, it is handled asynchronously by event handlers.

This handler:

* Receives `ProductCreatedEvent` from the event bus
* Creates a new `ProductEntity`
* Copies data from the event
* Saves it to the H2 read database

---

---

##############################################

*4.4. Data Persistence Layer*

* *ProductEntity*

  * JPA entity mapped to the `products` table
  * Fields: productId, title, price, quantity

* *ProductsRepository*

  * Extends `JpaRepository<ProductEntity, String>`
  * Provides CRUD operations automatically
  * Custom query methods supported

---

---

##############################################

== 4.5. Query Flow (Read Side)

When products are requested:

```
REST API → FindProductsQuery → QueryGateway → ProductsQueryHandler → H2 Database
```

The query side reads from the optimized read database without touching aggregates.

---

== 4.6. Eventual Consistency

* Write side is updated immediately
* Read side is updated asynchronously via events
* A small delay may exist between command execution and query availability

This is known as *eventual consistency*.

---

== 4.7. Additional Event Handlers

The system also supports:

* `ProductReservedEvent` → Decreases available quantity
* `ProductReservationCancelledEvent` → Restores quantity

---

== 4.8. Key Benefits

* Scalability: Read and write sides scale independently
* Performance: Optimized read models
* Audit Trail: Complete history via events
* Flexibility: New handlers can be added easily
* Resilience: Events can be replayed to rebuild state

---

== 4.9. Role of H2 Database

* Acts as the *read model database*
* In-memory and fast
* Ideal for development and testing
* Stores denormalized data optimized for queries

---
