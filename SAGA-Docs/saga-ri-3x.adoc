= CQRS Event-Driven Product Storage System
:toc: right
:toclevels:
:sectnums:
:sectnumlevel

== Architecture Overview

This system implements *CQRS (Command Query Responsibility Segregation)* with *Event Sourcing* using the Axon Framework.

---

image::./SAGA-Flow1.png[SAGA Flow 1]

---

The core idea is simple:

* Write operations (commands) and read operations (queries) are separated
* Every change in the system is recorded as an *event*
* Read data is built by listening to these events

---

== Command Flow (Write Side)

When a product is created, the following flow is executed:

```
REST API → CreateProductCommand → ProductAggregate → ProductCreatedEvent → Event Bus
```

---

*Step-by-Step Explanation (Simple Language)*

*1. REST API (User request entry point)*

* Create a product with this title, price, and quantity
* The REST controller:
** Only converts the request into a command

*In simple words:*: The user is telling the system *what they want to do*.

---

*2. CreateProductCommand (Instruction)*

* A command represents an *action request*.
* `CreateProductCommand` contains:

* productId, title, price, quantity

*In simple words:* This is a *written instruction* saying: “Create this product.”

---

*3. ProductAggregate (Decision maker)*

* The command is handled by the **ProductAggregate**.

* The aggregate:
** Acts as the *authority*
** Enforces business rules

* It checks:
** Is the data valid?
** Can this product be created?

* *If everything is valid*:
** It does *not* write to the database
** #It creates an event#

*In simple words:*
The aggregate decides:
“Yes, this operation is allowed.”

---

*4. ProductCreatedEvent (Something that already happened)*

* An event represents a *fact*.

* `ProductCreatedEvent` means:
** “The product has been created”

* Events are:
** Immutable (cannot be changed)
** Stored for history and auditing

*In simple words:* This is like a **receipt** confirming: “The product was created.”

---

*5. Event Bus (Announcement system)*

* The event is published to the **Event Bus**.

* The Event Bus:
** Broadcasts the event
** Delivers it to all interested listeners

* Examples of listeners:
** ProductEventsHandler (updates H2 database)
** Logging services
** Analytics services
** Notification services

*In simple words:*
The system announces:
“A product has been created!”

---

*One-Line Summary of the Flow*

* REST API → User request
* Command → What to do
* Aggregate → Is it allowed?
* Event → What happened
* Event Bus → Tell everyone

---

##############################################

*4.3. Event Processing (Event Sourcing)*

After the event is published, it is handled asynchronously by event handlers.

This handler:

* Receives `ProductCreatedEvent` from the event bus
* Creates a new `ProductEntity`
* Copies data from the event
* Saves it to the H2 read database

---

---

##############################################

*4.4. Data Persistence Layer*

* *ProductEntity*

  * JPA entity mapped to the `products` table
  * Fields: productId, title, price, quantity

* *ProductsRepository*

  * Extends `JpaRepository<ProductEntity, String>`
  * Provides CRUD operations automatically
  * Custom query methods supported

---

---

##############################################

== 4.5. Query Flow (Read Side)

When products are requested:

```
REST API → FindProductsQuery → QueryGateway → ProductsQueryHandler → H2 Database
```

The query side reads from the optimized read database without touching aggregates.

=== Query Flow with ProductsQueryHandler Role

* *HTTP GET /products*
Spring MVC routes the request to `ProductsQueryController.getProducts()`

* *Create Query Object*
A new query object is created:
`new FindProductsQuery()`
This is an empty query used to fetch all products

* *Dispatch via QueryGateway*
The controller calls:
`queryGateway.query()`
The query is sent to the Axon Query Bus

* *Route to ProductsQueryHandler*
Axon locates a method annotated with `@QueryHandler` in the `ProductsQueryHandler` class that accepts `FindProductsQuery`

* *ProductsQueryHandler Executes*
* Receives `FindProductsQuery` as input
* Calls `productsRepository.findAll()` to fetch all products from the H2 database
* Converts each `ProductEntity` to `ProductRestModel` using `BeanUtils.copyProperties()`
* Returns a list of `ProductRestModel` objects

* *Return Response*
The response flows back through:
`QueryGateway → Controller → JSON HTTP response`

* *ProductsQueryHandler Role*
Acts as a bridge between the Axon query mechanism and Spring Data JPA.
It is responsible for handling query-side business logic and transforming persistence models into API response models.


---

== 4.6. Eventual Consistency

* Write side is updated immediately
* Read side is updated asynchronously via events
* A small delay may exist between command execution and query availability

This is known as *eventual consistency*.

---

== 4.7. Additional Event Handlers

The system also supports:

* `ProductReservedEvent` → Decreases available quantity
* `ProductReservationCancelledEvent` → Restores quantity

---

== 4.8. Key Benefits

* Scalability: Read and write sides scale independently
* Performance: Optimized read models
* Audit Trail: Complete history via events
* Flexibility: New handlers can be added easily
* Resilience: Events can be replayed to rebuild state

---

== 4.9. Role of H2 Database

* Acts as the *read model database*
* In-memory and fast
* Ideal for development and testing
* Stores denormalized data optimized for queries

---


---

##############################################

=== Exception Handling

I'll examine both files to understand how error handling works between the interceptor and the error handler.

The [ProductsServiceErrorHandler]() handles exceptions from [CreateProductCommandInterceptor]() through Spring's `@ControllerAdvice` mechanism:

**Error Flow:**
1. [CreateProductCommandInterceptor](cci:2://file:///Users/nareshchaurasia/nc/Java-Architect/Java-CQRS-SAGA/ProductsService/src/main/java/com/appsdeveloperblog/estore/ProductsService/command/interceptors/CreateProductCommandInterceptor.java:16:0-54:1) throws `IllegalStateException` on line 43-46 when a duplicate product is found
2. The exception propagates up through the Axon framework
3. [ProductsServiceErrorHandler]() catches it via the `@ExceptionHandler` for `IllegalStateException` (lines 16-22)
4. Returns HTTP 500 with error details in JSON format

**Key Points:**
- The interceptor specifically throws `IllegalStateException` for duplicate products
- The error handler has a dedicated handler for `IllegalStateException` and a generic handler for other exceptions
- Both return `HttpStatus.INTERNAL_SERVER_ERROR` with timestamped error messages
- The `CommandExecutionException` handler (lines 31-36) would catch Axon-specific command failures

The error handling works automatically due to Spring's exception handling mechanism - no manual error propagation needed.