= ProductsService Flow Explanation
:toc: right
:toclevels: 5
:sectnums:5
:sectnumlevel: 5

== Product Creation Flow

=== 1. Client Sends HTTP Request
* POST to `/products` with product data in request body
* `CreateProductRestModel` contains price, quantity, title

=== 2. ProductsCommandController Receives Request
* `@PostMapping` method receives the HTTP request
* Creates `CreateProductCommand` from REST model data
* Generates random `productId` using `UUID.randomUUID()`

=== 3. CommandGateway Sends Command
* `commandGateway.sendAndWait(createProductCommand)` sends command to Axon
* This is the entry point to the CQRS system
* Controller waits for response before continuing

=== 4. CreateProductCommandInterceptor Checks
* `ProductLookupRepository.findByProductIdOrTitle()`
* If product exists → throws `IllegalStateException`
* If not exists → continues to next step

=== 5. ProductAggregate Handles Command
* `@CommandHandler` constructor receives `CreateProductCommand`
* Validates: price > 0, title not empty
* Creates `ProductCreatedEvent`
* Calls `AggregateLifecycle.apply(productCreatedEvent)`

=== 6. Event Bus Broadcasts
* Axon Framework Event Bus broadcasts `ProductCreatedEvent`
* All event handlers receive the event

=== 7. ProductEventsHandler Updates Database
* `@EventHandler` method receives `ProductCreatedEvent`
* Creates new `ProductEntity` from event data
* Saves to `ProductsRepository` (read database)

=== 8. Client Gets Response
* HTTP 201 Created returned to client
* Product now available for queries

=== Key Components in Your Code

* **REST Controller**: ProductsCommandController
* **Gateway**: CommandGateway (Axon entry point)
* **Command**: CreateProductCommand
* **Interceptor**: CreateProductCommandInterceptor
* **Aggregate**: ProductAggregate
* **Event**: ProductCreatedEvent
* **Event Handler**: ProductEventsHandler
* **Error Handler**: ProductsServiceErrorHandler

=== Complete Flow Summary

1. **HTTP Request** → 2. **Controller** → 3. **CommandGateway** → 4. **Interceptor Validation** → 5. **Aggregate Processing** → 6. **Event Creation** → 7. **Database Update** → 8. **Response**

This shows the complete flow from HTTP request to database update.

##############################################

== ProductsService Exception Handling & Rollback


=== 1. Controller Level
* **No exception handling** in current code
* Commented out try-catch shows intended pattern:
```java
try {
    returnValue = commandGateway.sendAndWait(createProductCommand);
} catch (Exception ex) {
    returnValue = ex.getLocalizedMessage();
}
```

=== 2. CommandGateway Level
* `sendAndWait()` propagates exceptions to controller
* If any downstream component throws exception, it bubbles up here

=== 3. Interceptor Level
* **Throws**: `IllegalStateException` for duplicate products
* **Handled by**: [ProductsServiceErrorHandler.handleIllegalStateException()](cci:1://file:///Users/nareshchaurasia/nc/Java-Architect/Java-CQRS-SAGA/ProductsService/src/main/java/com/appsdeveloperblog/estore/ProductsService/core/errorhandling/ProductsServiceErrorHandler.java:15:1-21:2)
* **Returns**: HTTP 500 with error message
* **No rollback needed** - no changes made yet

=== 4. Aggregate Level
* **Throws**: `IllegalArgumentException` for invalid data (price <= 0, empty title)
* **Handled by**: [ProductsServiceErrorHandler.handleOtherExceptions()](cci:1://file:///Users/nareshchaurasia/nc/Java-Architect/Java-CQRS-SAGA/ProductsService/src/main/java/com/appsdeveloperblog/estore/ProductsService/core/errorhandling/ProductsServiceErrorHandler.java:23:1-28:2)
* **Returns**: HTTP 500 with error message
* **No rollback needed** - event not applied yet

=== 5. Event Handler Level
* **Throws**: Exceptions during database operations
* **Handled by**: [ProductsServiceEventsErrorHandler.onError()](cci:1://file:///Users/nareshchaurasia/nc/Java-Architect/Java-CQRS-SAGA/ProductsService/src/main/java/com/appsdeveloperblog/estore/ProductsService/core/errorhandling/ProductsServiceEventsErrorHandler.java:8:1-12:2)
* **Action**: Re-throws exception (can be configured for retry)
* **Rollback**: Event not marked as processed, will be retried

== Rollback Mechanisms

=== Event Sourcing Rollback
* **Aggregate state** rebuilt from event stream
* If event processing fails, aggregate state unchanged
* Next retry will process same event again

=== Database Transaction Rollback
* `@Transactional` on event handler methods
* If database save fails, transaction rolls back
* Event remains unprocessed, will be retried

=== Command Gateway Rollback
* If any component throws exception, command fails
* No partial state changes occur
* Client receives error response

== Error Handler Chain

=== Primary Error Handlers
1. **ProductsServiceErrorHandler** - HTTP layer exceptions
2. **ProductsServiceEventsErrorHandler** - Event processing exceptions

=== Exception Flow
```
Interceptor → IllegalStateException → ProductsServiceErrorHandler → HTTP 500
Aggregate → IllegalArgumentException → ProductsServiceErrorHandler → HTTP 500  
EventHandler → DatabaseException → ProductsServiceEventsErrorHandler → Retry
```

== Rollback Scenarios

=== Scenario 1: Duplicate Product
1. Interceptor throws `IllegalStateException`
2. **No changes made** to database
3. **No rollback needed**
4. Client gets HTTP 500

=== Scenario 2: Invalid Price
1. Aggregate validates and throws `IllegalArgumentException`
2. **Event not applied** to aggregate
3. **No database changes**
4. Client gets HTTP 500

=== Scenario 3: Database Failure
1. Event handler tries to save to database
2. Database throws exception
3. **Transaction rolls back**
4. **Event will be retried** by Axon
5. Aggregate state unchanged

== Key Points for Interview

* **Fail fast** - validate early, fail early
* **No partial state** - either complete success or complete failure
* **Event sourcing** provides natural rollback mechanism
* **Transaction boundaries** at event handler level
* **Retry mechanisms** built into Axon framework

== Exception Handling Summary

**Controller → Gateway → Interceptor → Aggregate → Event Handler**
↓ ↓ ↓ ↓ ↓
**HTTP Error** → **Command Fails** → **Validation Error** → **Business Error** → **Data Error**

Each layer has appropriate error handling with minimal rollback complexity due to event sourcing design.


##############################################

*Order*

* Create Product
* Create Order for above Product
** It is reserved
* You can create multiple orders for same product. It will have different orderId

---

The sender (OrderService) and receiver (ProductService) communicate via a message bus, typically orchestrated by the Axon Framework, which utilizes Axon Server as a message router and event store.

Here’s how they link to the same bus:

* Configuration: Both services are configured to use Axon Server for messaging. In their application configurations, they specify the Axon Server's connection details, allowing them to publish and listen to messages on the same bus.

* Command and Event Handling: When the OrderService sends a command (such as ReserveProductCommand), that command is dispatched to the Axon Server. The ProductService must have an appropriate command handler defined (marked with @CommandHandler) to process the command.

* Location Transparency: The microservices do not need to be aware of each other's locations; they communicate through the bus, which abstracts these details. This concept aligns with the principle of location transparency, where microservices operate independently.

* Event Dispatching: Once the command is handled and an event is published (e.g., ProductReservedEvent), this event is also sent to the Axon Server. Any microservices that have registered with Axon Server to listen for this specific event will automatically receive it.

By utilizing Axon Server for both command and event dispatching, both the sender and the receiver can seamlessly communicate over the same bus without needing direct knowledge of each other's implementations. This setup promotes a scalable and loosely coupled architecture.